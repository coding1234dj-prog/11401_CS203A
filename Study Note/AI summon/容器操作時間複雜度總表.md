# 容器操作時間複雜度總表

## 📊 快速查找表

| 資料結構 | 存取 | 搜尋 | 插入 | 刪除 | 空間 | 備註 |
|---------|------|------|------|------|------|------|
| **Array** | O(1) | O(n) | - | - | O(n) | 固定大小 |
| **Dynamic Array** | O(1) | O(n) | O(1)* | O(n) | O(n) | *尾部攤銷 |
| **Linked List** | O(n) | O(n) | O(1)** | O(1)** | O(n) | **已知位置 |
| **Doubly Linked List** | O(n) | O(n) | O(1)** | O(1)** | O(n) | 可雙向遍歷 |
| **Stack** | O(1)† | - | O(1) | O(1) | O(n) | †僅頂部 |
| **Queue** | O(1)† | - | O(1) | O(1) | O(n) | †僅頭尾 |
| **Deque** | O(1) | O(n) | O(1) | O(1) | O(n) | 兩端操作 |
| **Hash Table** | - | O(1)‡ | O(1)‡ | O(1)‡ | O(n) | ‡平均，最壞 O(n) |
| **Binary Search Tree** | - | O(log n)‡ | O(log n)‡ | O(log n)‡ | O(n) | ‡平均，最壞 O(n) |
| **AVL Tree** | - | O(log n) | O(log n) | O(log n) | O(n) | 保證平衡 |
| **Red-Black Tree** | - | O(log n) | O(log n) | O(log n) | O(n) | 較 AVL 寬鬆 |
| **B-Tree** | - | O(log n) | O(log n) | O(log n) | O(n) | 多路平衡樹 |
| **Binary Heap** | O(1)§ | O(n) | O(log n) | O(log n)§ | O(n) | §僅 min/max |
| **Trie** | O(m) | O(m) | O(m) | O(m) | O(ALPHABET×n×m) | m = 字串長度 |

## 📦 Stack（堆疊）- LIFO

### 基本操作
```
操作          時間    說明                    實例
push()        O(1)    壓入元素                 盤子疊最上面
pop()         O(1)    彈出頂部元素             拿走最上面的盤子
peek()/top()  O(1)    查看頂部但不移除         看一眼不拿走
isEmpty()     O(1)    檢查是否為空             
size()        O(1)    取得元素數量             
```

### 實作方式對比
```
Array-based Stack:
✓ 快取友善
✓ 記憶體連續
✗ 需要預估容量或 resize

List-based Stack:
✓ 動態大小
✓ 不需 resize
✗ 記憶體不連續（指標開銷）
✗ 快取效率較差

推薦：大多數情況用 Array-based
```

### 典型應用
```
✓ 函數呼叫棧（Call Stack）
✓ 括號匹配檢查
✓ 表達式求值（中綴轉後綴）
✓ 深度優先搜尋（DFS）
✓ 瀏覽器歷史記錄（後退功能）
✓ 編輯器的 Undo 功能
```

## 📮 Queue（佇列）- FIFO

### 基本操作
```
操作          時間    說明                    實例
enqueue()     O(1)    加入尾部                 排隊排到最後
dequeue()     O(1)    移除頭部                 第一個人離開
front()       O(1)    查看頭部                 看誰在最前面
rear()        O(1)    查看尾部                 看誰在最後面
isEmpty()     O(1)    檢查是否為空             
size()        O(1)    取得元素數量             
```

### 實作方式對比
```
Circular Array:（最常見）
✓ 空間效率高
✓ 快取友善
✓ 實作稍複雜（需處理循環）

Linked List:
✓ 實作簡單
✓ 動態大小
✗ 指標開銷

兩個 Stack:
✗ dequeue 可能 O(n)（需倒轉）
✓ 攤銷 O(1)
✗ 不推薦（複雜且浪費）
```

### 典型應用
```
✓ 任務調度（Task Scheduler）
✓ 廣度優先搜尋（BFS）
✓ 打印機佇列
✓ 訊息佇列（Message Queue）
✓ 緩衝區（Buffer）
✓ CPU 資源排程
```

## ↔️ Deque（雙端佇列）- Double-Ended Queue

### 基本操作
```
操作              時間    說明
pushFront()       O(1)    頭部插入
pushBack()        O(1)    尾部插入
popFront()        O(1)    頭部刪除
popBack()         O(1)    尾部刪除
front()           O(1)    查看頭部
back()            O(1)    查看尾部
at(index)         O(1)    隨機存取（部分實作支援）
```

### 實作方式對比
```
分段陣列（C++ std::deque）:
✓ 兩端都 O(1)
✓ 隨機存取 O(1)
✓ 不需連續記憶體
✗ 實作複雜
結構：map of chunks（多個小陣列）

雙向鏈表:
✓ 兩端都 O(1)
✓ 實作簡單
✗ 無法隨機存取 O(n)
✗ 記憶體開銷大
```

### 與 Stack/Queue 的關係
```
Deque 是超集：
- 可當 Stack 用（只用一端）
- 可當 Queue 用（一端進一端出）
- 提供更多靈活性

但為何不總是用 Deque？
1. Stack/Queue 語義更清晰
2. 限制即文檔（防誤用）
3. 某些語言 Stack/Queue 有特殊優化
```

### 典型應用
```
✓ 滑動窗口最大值（單調佇列）
✓ 雙向搜尋
✓ LRU Cache（配合 HashMap）
✓ 工作排程器（可優先級調整）
✓ 回文檢查
```

## 🔺 Priority Queue（優先佇列）

### 基本操作
```
操作              時間        說明
insert/push()     O(log n)    插入元素
extractMax/pop()  O(log n)    取出並刪除最大值
getMax/top()      O(1)        查看最大值（不刪除）
heapify()         O(n)        從陣列建立堆
changePriority()  O(log n)    修改元素優先級
```

### 實作方式對比
```
Binary Heap:（最常見）
✓ 實作簡單（用陣列）
✓ 空間效率高
✓ 快取友善
✗ 不支援快速查找任意元素

Fibonacci Heap:（理論最優）
✓ insert/decrease-key O(1) 攤銷
✓ 理論上最優
✗ 實作極度複雜
✗ 常數因子大
✗ 實務幾乎不用

Balanced BST:（如 TreeMap）
✓ 支援範圍查詢
✓ 可找任意第 k 大
✗ O(log n) 所有操作
✗ 記憶體開銷大
```

### Max Heap vs Min Heap
```
Max Heap: 父節點 ≥ 子節點
- 根是最大值
- 用於找最大的 K 個元素

Min Heap: 父節點 ≤ 子節點
- 根是最小值
- 用於找最小的 K 個元素

語言預設：
Java:    Min Heap (PriorityQueue)
C++:     Max Heap (priority_queue)
Python:  Min Heap (heapq)
```

### 典型應用
```
✓ Top K 問題（前 K 大/小）
✓ 任務調度（按優先級）
✓ Dijkstra 最短路徑
✓ Huffman 編碼
✓ 中位數維護（兩個 Heap）
✓ 合併 K 個有序鏈表
✓ 作業系統排程
```

## 🔍 Hash Table（雜湊表）

### 基本操作
```
操作          平均      最壞      說明
put/insert()  O(1)      O(n)     鍵值對插入
get/search()  O(1)      O(n)     查找鍵
remove()      O(1)      O(n)     刪除鍵
contains()    O(1)      O(n)     檢查是否存在
遍歷所有元素   O(n)      O(n)     無序遍歷
```

### 影響效能的關鍵因素
```
1. 負載因子（Load Factor）
   α = n / m （n=元素數, m=桶數）
   - Java HashMap: 預設 0.75
   - 太高 → 碰撞多 → 變慢
   - 太低 → 空間浪費

2. 雜湊函數品質
   好的雜湊函數：
   ✓ 均勻分佈
   ✓ 快速計算
   ✓ 避免碰撞

3. 碰撞處理策略
   - Chaining: 鏈表連接（更常見）
   - Open Addressing: 線性探測
```

### 何時退化到 O(n)
```
最壞情況：
1. 惡意輸入（Hash DoS 攻擊）
2. 雜湊函數設計不良
3. 所有鍵碰撞到同一個桶

Java 8+ 優化：
桶內元素 > 8 時轉為紅黑樹
最壞降為 O(log n)
```

### 典型應用
```
✓ 快取（Cache）
✓ 資料庫索引（雜湊索引）
✓ 去重（Set）
✓ 計數（Counter）
✓ 兩數之和問題
✓ 字典查找
```

## 🌲 Binary Search Tree（二元搜尋樹）

### 基本操作
```
操作          平均       最壞      說明
search()      O(log n)   O(n)     查找值
insert()      O(log n)   O(n)     插入值
delete()      O(log n)   O(n)     刪除值
min()/max()   O(log n)   O(n)     找極值
successor()   O(log n)   O(n)     找後繼節點
inorder()     O(n)       O(n)     有序遍歷
```

### 何時退化到 O(n)
```
退化成鏈狀：
輸入：1 → 2 → 3 → 4 → 5
結果：
    1
     \
      2
       \
        3
         \
          4
           \
            5

時間複雜度：O(n)（等同於鏈表）
```

### 防止退化的方法
```
方法 1: 使用平衡樹（最標準）
- AVL Tree
- Red-Black Tree
- B-Tree

方法 2: 打亂輸入
- 適合一次性建構
- shuffle + insert

方法 3: 隨機化樹
- Treap（隨機優先級）
- Skip List
```

## ⚖️ Self-Balancing Trees（自平衡樹）

### AVL Tree vs Red-Black Tree

```
             AVL Tree          Red-Black Tree
────────────────────────────────────────────────
平衡度       嚴格（高度差≤1）   寬鬆（最長≤2×最短）
樹高         ~1.44 log n       ~2 log n
查詢         最快               稍慢
插入         較慢               較快
刪除         最慢（可能O(log n)次旋轉） 快（最多3次旋轉）
旋轉次數     較多               較少
實作複雜度   中等               困難（40+情況）
使用場景     查詢密集           讀寫平衡
實際應用     較少               C++ STL, Java TreeMap
```

### 操作複雜度（都保證）
```
操作              時間複雜度
search()          O(log n)
insert()          O(log n)
delete()          O(log n)
min()/max()       O(log n)
predecessor()     O(log n)
successor()       O(log n)
range query       O(k + log n)  k=結果數
```

### B-Tree（多路平衡樹）
```
特點：
- 每個節點可有多個子節點（如 B+Tree: 100-200）
- 高度極低（通常 3-4 層即可存百萬數據）
- 磁碟 I/O 友善

操作：
- 所有操作 O(log n)
- 範圍查詢高效（葉節點連結）

應用：
✓ 資料庫索引（MySQL InnoDB）
✓ 檔案系統（NTFS, ext4）
✓ 磁碟儲存結構
```

## 📊 空間複雜度對照

| 資料結構 | 空間複雜度 | 額外開銷（每元素） |
|---------|-----------|------------------|
| Array | O(n) | 0 |
| Dynamic Array | O(n) | 0（但有未用空間） |
| Linked List | O(n) | 8-16 bytes（1-2指標） |
| Hash Table | O(n) | 負載因子相關（通常1.5n空間） |
| Binary Tree | O(n) | 16 bytes（2指標） |
| AVL Tree | O(n) | 20 bytes（2指標+高度） |
| Red-Black Tree | O(n) | 17 bytes（2指標+顏色） |
| Binary Heap | O(n) | 0（用陣列） |
| Trie | O(ALPHABET_SIZE × n × m) | 極大（空間換時間） |

## 🎯 面試常考比較題

### Q1: 用兩個 Stack 實作 Queue

```java
class QueueWithTwoStacks {
    Stack<Integer> s1 = new Stack<>(); // 入隊
    Stack<Integer> s2 = new Stack<>(); // 出隊
    
    void enqueue(int x) {
        s1.push(x);  // O(1)
    }
    
    int dequeue() {
        if (s2.isEmpty()) {
            while (!s1.isEmpty()) {
                s2.push(s1.pop());  // 倒轉
            }
        }
        return s2.pop();  // O(1) 攤銷
    }
}

時間複雜度分析：
- enqueue: O(1)
- dequeue: O(1) 攤銷（單次可能 O(n)）
```

### Q2: 為什麼 Binary Heap 不用 BST？

```
需求：只需要最大/最小值

Heap 優勢：
✓ getMin: O(1) vs BST O(log n)
✓ 實作簡單（陣列即可）
✓ 空間效率高（無指標）
✓ 快取友善

BST 優勢：
✓ 支援搜尋任意值
✓ 支援範圍查詢
✓ 支援有序遍歷

結論：
只需極值 → Heap
需要搜尋 → BST
```

### Q3: Deque vs Stack+Queue

```
問：為什麼不總是用 Deque？

答：
1. 語義清晰
   Stack/Queue 表達明確意圖
   限制即文檔

2. 防止誤用
   Stack 不應該從底部取元素
   明確的接口防止錯誤

3. 效能優化
   某些語言對 Stack/Queue 有特殊優化

使用 Deque 的時機：
✓ 真的需要雙端操作
✓ 滑動窗口問題
✓ 靈活性優先於語義
```

### Q4: Hash Table 什麼時候比 TreeMap 慢？

```
Hash 慢於 Tree 的情況：

1. 需要有序遍歷
   Hash: O(n log n) 需排序
   Tree: O(n) 中序遍歷

2. 範圍查詢
   Hash: O(n) 遍歷全部
   Tree: O(k + log n)

3. 需要穩定效能
   Hash: 最壞 O(n)
   Tree: 保證 O(log n)

4. 極端碰撞
   惡意構造輸入
   雜湊函數設計不良
```

## 💡 選擇建議

### 決策流程圖
```
需要容器？
    ↓
只需一端操作？
    ↓ 是              ↓ 否
    哪一端？           需要兩端？
    ↓ 頂部      ↓ 頭尾     ↓ 是      ↓ 否
    Stack      Queue     Deque    需排序？
                                 ↓ 是    ↓ 否
                                 Tree   Hash

需要快速找極值？
    ↓ 是
    Priority Queue (Heap)
```

### 預設選擇建議
```
純查找                → HashMap
需要順序              → TreeMap (Red-Black)
需要極值              → PriorityQueue (Heap)
LIFO                 → Stack
FIFO                 → Queue
兩端都要操作           → Deque
不確定               → 先用 HashMap 試試
```

## 🔑 記憶口訣

```
Array 連續塊，隨機快但不能長
List 鏈起來，插刪快但找得慢
Stack 疊盤子，後進先出要記牢
Queue 排隊伍，先來先走不能插
Deque 雙頭蛇，兩邊都能吃東西
Heap 堆成山，只看山頂不管腰
Hash 散列開，平均最快怕碰撞
Tree 長成樹，有序穩定但較慢

選擇口訣：
能用 Hash 就用 Hash（不需順序）
需要順序找 Tree（紅黑最穩當）
只要極值用 Heap（Priority Queue）
特定操作配專用（Stack/Queue/Deque）
```

---

**複習重點：**
1. 能說出每個結構的時間複雜度（平均和最壞）
2. 理解為什麼 Hash O(1) 但不是萬能
3. 知道何時需要平衡樹而非普通 BST
4. 熟悉 Stack/Queue 的互相實作
5. 理解 Heap 為什麼適合 Priority Queue
