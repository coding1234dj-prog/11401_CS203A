# 線性結構比較：Array vs LinkedList vs Vector vs Deque

## 核心差異對照表

| 特性 | Array | LinkedList | Vector | Deque |
|------|-------|------------|--------|-------|
| **記憶體配置** | 連續 | 分散（節點） | 連續（動態） | 分段連續 |
| **隨機存取** | O(1) | O(n) | O(1) | O(1) |
| **頭部插入** | O(n) | O(1) | O(n) | O(1) |
| **尾部插入** | - | O(1) | O(1) 攤銷 | O(1) 攤銷 |
| **中間插入** | - | O(n) | O(n) | O(n) |
| **刪除元素** | - | O(1)* | O(n) | O(n) |
| **記憶體效率** | 最高 | 低（額外指標） | 高 | 中等 |
| **快取友善度** | 最好 | 差 | 好 | 中等 |

*前提是已經定位到節點

## 什麼時候用哪個？

### Array（靜態陣列）
```
使用時機：
✓ 大小固定且已知
✓ 需要最快的隨機存取
✓ 記憶體極度受限
✓ 不需要插入/刪除操作

典型場景：
- 查找表、配置檔案
- 數學矩陣運算
- 圖像處理（像素陣列）
```

### LinkedList（鏈結串列）
```
使用時機：
✓ 頻繁的插入/刪除操作
✓ 不需要隨機存取
✓ 大小動態變化且難以預測
✓ 實作 Queue、Stack 等結構

典型場景：
- LRU Cache 實作
- 音樂播放列表（可雙向移動）
- 瀏覽器歷史記錄（前進/後退）
- 記憶體管理（free list）
```

### Vector（動態陣列）
```
使用時機：
✓ 需要隨機存取 + 動態增長
✓ 主要在尾部操作
✓ 不確定最終大小
✓ 需要較好的快取效能

典型場景：
- 通用資料收集
- 動態資料處理
- 大多數「不確定用什麼」的情況
- 作為其他結構的底層實作
```

### Deque（雙端佇列）
```
使用時機：
✓ 需要兩端都能快速插入/刪除
✓ 需要隨機存取
✓ 實作滑動窗口演算法
✓ BFS 等需要 Queue 但偶爾需要存取的場景

典型場景：
- 滑動窗口最大值
- 工作排程器（優先級調整）
- 回文檢查
- BFS with 多個起點
```

## 面試高頻問題

### Q1: 為什麼 Vector 尾部插入是 O(1) 攤銷？
**答案：** 容量不足時需要重新配置（通常 2 倍擴容），單次 O(n) 但分攤到多次操作後平均 O(1)。

### Q2: LinkedList 什麼情況下比 Vector 快？
**答案：** 
- 已知位置的插入/刪除
- 頻繁的頭部操作
- 需要穩定的插入時間（不會有 Vector 的擴容延遲）

### Q3: Deque 和 Vector 的本質區別？
**答案：** 
- Deque 通常使用分段陣列（map of blocks）
- Vector 必須連續，Deque 可以分段
- Deque 兩端都能 O(1)，Vector 只有尾端

### Q4: 為什麼現代系統更偏好 Array/Vector？
**答案：**
- CPU 快取行為：連續記憶體預取效率高
- 記憶體局部性：降低 cache miss
- LinkedList 的指標開銷大（每個節點額外 8-16 bytes）
- 現代處理器對連續資料的優化極好

## 實務建議

### 預設選擇
```
不確定時的最佳選擇：Vector/ArrayList

理由：
1. 對小資料量差異不明顯
2. 現代硬體對連續記憶體友善
3. 工具鏈優化成熟
4. 程式碼維護性好
```

### 何時違反預設
```
使用 LinkedList：
- 實作特定資料結構（LRU、雙向鏈表問題）
- 已知會有大量中間插入刪除
- 記憶體碎片化環境

使用 Deque：
- 演算法明確需要雙端操作
- 滑動窗口類問題
- 需要 Queue 但可能需要隨機存取

保持 Array：
- 嵌入式系統
- 效能關鍵路徑
- 大小真的固定
```

## 記憶技巧

```
Array:    固定快取王 → 速度但不靈活
Vector:   萬用膠帶紙 → 不知道用啥就用它
LinkedList: 彈簧鏈條 → 彎曲容易但找東西慢
Deque:    雙頭蛇 → 兩邊都靈活
```

## 延伸思考

1. **為什麼 Java 的 ArrayList 叫 List 不叫 Vector？**
   - 歷史原因：Java 原本的 Vector 是線程安全的（synchronized），效能差
   - ArrayList 是後來加入的非同步版本

2. **C++ vector 真的是最好的預設嗎？**
   - 對小物件（≤64 bytes）絕對是
   - 大物件考慮 vector<unique_ptr<T>> 避免複製

3. **為什麼資料庫索引不用 Vector？**
   - 插入成本太高（O(n)）
   - 實際使用 B-Tree（平衡的多路搜尋樹）

---

**下一步：** 學習容器操作時間複雜度總表
