# 線性結構比較：Array vs LinkedList vs Vector vs Deque

## 核心差異對照表

| 特性 | Array | LinkedList | Vector | Deque |
|------|-------|------------|--------|-------|
| **記憶體配置** | 連續 | 分散（節點） | 連續（動態） | 分段連續 |
| **隨機存取** | O(1) | O(n) | O(1) | O(1) |
| **頭部插入** | O(n) | O(1) | O(n) | O(1) |
| **尾部插入** | - | O(1) | O(1) 攤銷 | O(1) 攤銷 |
| **中間插入** | - | O(n) | O(n) | O(n) |
| **刪除元素** | - | O(1)* | O(n) | O(n) |
| **記憶體效率** | 最高 | 低（額外指標） | 高 | 中等 |
| **快取友善度** | 最好 | 差 | 好 | 中等 |

*前提是已經定位到節點

## 什麼時候用哪個？

### Array（靜態陣列）
```
使用時機：
✓ 大小固定且已知
✓ 需要最快的隨機存取
✓ 記憶體極度受限
✓ 不需要插入/刪除操作

典型場景：
- 查找表、配置檔案
- 數學矩陣運算
- 圖像處理（像素陣列）
```

### LinkedList（鏈結串列）
```
使用時機：
✓ 頻繁的插入/刪除操作
✓ 不需要隨機存取
✓ 大小動態變化且難以預測
✓ 實作 Queue、Stack 等結構

典型場景：
- LRU Cache 實作
- 音樂播放列表（可雙向移動）
- 瀏覽器歷史記錄（前進/後退）
- 記憶體管理（free list）
```

### Vector（動態陣列）
```
使用時機：
✓ 需要隨機存取 + 動態增長
✓ 主要在尾部操作
✓ 不確定最終大小
✓ 需要較好的快取效能

典型場景：
- 通用資料收集
- 動態資料處理
- 大多數「不確定用什麼」的情況
- 作為其他結構的底層實作
```

### Deque（雙端佇列）
```
使用時機：
✓ 需要兩端都能快速插入/刪除
✓ 需要隨機存取
✓ 實作滑動窗口演算法
✓ BFS 等需要 Queue 但偶爾需要存取的場景

典型場景：
- 滑動窗口最大值
- 工作排程器（優先級調整）
- 回文檢查
- BFS with 多個起點
```

### 預設選擇
```
不確定時的最佳選擇：Vector/ArrayList

理由：
1. 對小資料量差異不明顯
2. 現代硬體對連續記憶體友善
3. 工具鏈優化成熟
4. 程式碼維護性好
```

### 何時違反預設
```
使用 LinkedList：
- 實作特定資料結構（LRU、雙向鏈表問題）
- 已知會有大量中間插入刪除
- 記憶體碎片化環境

使用 Deque：
- 演算法明確需要雙端操作
- 滑動窗口類問題
- 需要 Queue 但可能需要隨機存取

保持 Array：
- 嵌入式系統
- 效能關鍵路徑
- 大小真的固定
```

## 記憶技巧

```
Array:    固定快取王 → 速度但不靈活
Vector:   萬用膠帶紙 → 不知道用啥就用它
LinkedList: 彈簧鏈條 → 彎曲容易但找東西慢
Deque:    雙頭蛇 → 兩邊都靈活
```

